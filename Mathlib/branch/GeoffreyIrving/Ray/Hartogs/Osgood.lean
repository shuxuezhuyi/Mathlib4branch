/-
Copyright (c) 2023 Geoffrey Irving. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Geoffrey Irving
-/
import Mathlib.Analysis.Analytic.Basic
import Mathlib.Analysis.Complex.CauchyIntegral
import Mathlib.Analysis.InnerProductSpace.EuclideanDist
import Mathlib.Analysis.Normed.Field.InfiniteSum
import Mathlib.Analysis.Normed.Group.Basic
import Mathlib.Analysis.NormedSpace.Multilinear
import Mathlib.Data.Complex.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Real.ENNReal
import Mathlib.Data.Real.NNReal
import Mathlib.Data.Real.Pi.Bounds
import Mathlib.Data.Set.Basic
import Mathlib.Data.Set.Function
import Mathlib.MeasureTheory.Measure.MeasureSpaceDef
import Mathlib.Topology.Algebra.Module.Multilinear
import Mathlib.Topology.Basic
import Mathlib.branch.GeoffreyIrving.Ray.Analytic.Analytic
import Mathlib.branch.GeoffreyIrving.Ray.Tactic.Bound
import Mathlib.branch.GeoffreyIrving.Ray.Misc.Bounds
import Mathlib.branch.GeoffreyIrving.Ray.Misc.Multilinear
import Mathlib.branch.GeoffreyIrving.Ray.Misc.Topology

/-!
## Osgood's lemma for two variables

We show that continuous, separately analytic functions over ‚ÑÇ are jointly analytic:

  https://en.wikipedia.org/wiki/Osgood's_lemma

The continuity assumption is unnecessary: see `Hartogs.lean` for the stronger version requiring only
separate analyticity.  We prove it for two variables only, as that's all we need; if more variables
if need, Hartogs' should be generalized, not Osgood's.

## Proof details

Osgood's lemma follows from the multidimensional Cauchy integral formula

  `f c = (2œÄi)^(-d) (prod_k ‚à´_(C k) d(z k)) (prod_k (z k - c k)‚Åª¬π) f z`

The `n`th multidimensional coefficient (with `n : fin d ‚Üí ‚Ñï`) looks like

  `p n = (2œÄi)^(-d) (prod_k ‚à´_(C k) d(z k)) (prod_k (z k - c k)^(-1 - n k)) f z`

For a quick refresher on why the Cauchy power series works, for `c = 0`:

  f_n = (2œÄi)‚Åª¬π ‚à´_C dz z^(-1-n) * f z
  f w = (2œÄi)‚Åª¬π ‚à´_C dz (z - w)‚Åª¬π * f z
      = (2œÄi)‚Åª¬π ‚à´_C dz (z - z * (w/z))‚Åª¬π * f z
      = (2œÄi)‚Åª¬π ‚à´_C dz (1 - w/z)‚Åª¬π * z‚Åª¬π * f z
      = (2œÄi)‚Åª¬π ‚à´_C dz Œ£_n (w/z)^n * z‚Åª¬π * f z
      = Œ£_n w^n (2œÄi)‚Åª¬π ‚à´_C dz  z‚Åª¬π^n * z‚Åª¬π * f z
-/

-- Remove once https://github.com/leanprover/lean4/issues/2220 is fixed
local macro_rules | `($x ^ $y) => `(HPow.hPow $x $y)

open Complex (abs exp I log)
open Filter (atTop)
open Function (curry uncurry)
open Metric (ball closedBall sphere isOpen_ball)
open intervalIntegral
open scoped Real NNReal ENNReal Topology MeasureTheory
noncomputable section

section osgood

variable {E : Type} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E] [CompleteSpace E]
variable {f : ‚ÑÇ √ó ‚ÑÇ ‚Üí E}
variable {s : Set (‚ÑÇ √ó ‚ÑÇ)}
variable {c0 c1 w0 w1 : ‚ÑÇ}
variable {r b : ‚Ñù}

/-- A measureable, separately analytic function of 2 complex variables near `c`.
    We assume `f` is differentiable in an open neighborhood of the closedBall for simplicity. -/
structure Separate (f : ‚ÑÇ √ó ‚ÑÇ ‚Üí E) (c0 c1 : ‚ÑÇ) (r b : ‚Ñù) (s : Set (‚ÑÇ √ó ‚ÑÇ)) : Prop where
  rp : 0 < r
  so : IsOpen s
  rs : closedBall (c0, c1) r ‚äÜ s
  fc : ContinuousOn f s
  fa0 : ‚àÄ {c0 c1}, (c0, c1) ‚àà s ‚Üí AnalyticAt ‚ÑÇ (fun z0 ‚Ü¶ f (z0, c1)) c0
  fa1 : ‚àÄ {c0 c1}, (c0, c1) ‚àà s ‚Üí AnalyticAt ‚ÑÇ (fun z1 ‚Ü¶ f (c0, z1)) c1
  bp : 0 ‚â§ b
  fb : ‚àÄ {z0 z1}, z0 ‚àà sphere c0 r ‚Üí z1 ‚àà sphere c1 r ‚Üí ‚Äñf (z0, z1)‚Äñ ‚â§ b

theorem spheres_subset_closedBall {c0 c1 : ‚ÑÇ} {r : ‚Ñù} :
    sphere c0 r √óÀ¢ sphere c1 r ‚äÜ closedBall (c0, c1) r := by
  rw [‚ÜêclosedBall_prod_same, Set.subset_def]; intro z
  simp only [Set.mem_prod, mem_sphere_iff_norm, Complex.norm_eq_abs, Metric.mem_closedBall, and_imp]
  rw [Complex.dist_eq, Complex.dist_eq]
  intro a b; exact ‚ü®le_of_eq a, le_of_eq b‚ü©

theorem Separate.rs' (h : Separate f c0 c1 r b s) : sphere c0 r √óÀ¢ sphere c1 r ‚äÜ s :=
  le_trans spheres_subset_closedBall h.rs

theorem mem_open_closed {z c : ‚ÑÇ} {r : ‚Ñù} : z ‚àà ball c r ‚Üí z ‚àà closedBall c r := by
  simp only [Metric.mem_ball, Metric.mem_closedBall]; exact le_of_lt

theorem mem_sphere_closed {z c : ‚ÑÇ} {r : ‚Ñù} : z ‚àà sphere c r ‚Üí z ‚àà closedBall c r := by
  simp only [mem_sphere_iff_norm, Complex.norm_eq_abs, Metric.mem_closedBall]; exact le_of_eq

/-- Spheres don't contain their center -/
theorem center_not_in_sphere {c z : ‚ÑÇ} {r : ‚Ñù} (rp : r > 0) (zs : z ‚àà sphere c r) : z - c ‚â† 0 := by
  simp only [mem_sphere_iff_norm, Complex.norm_eq_abs] at zs
  rw [‚ÜêComplex.abs.ne_zero_iff, zs]; exact rp.ne'

/-- `f` is continuous in `z0` -/
theorem Separate.fc0 (h : Separate f c0 c1 r b s) (w1m : w1 ‚àà ball c1 r) :
    ContinuousOn (fun z0 ‚Ü¶ f (z0, w1)) (closedBall c0 r) := by
  refine' ContinuousOn.comp h.fc _ _
  exact ContinuousOn.prod continuousOn_id continuousOn_const
  intro z0 z0m; apply h.rs
  rw [‚Üê closedBall_prod_same]; exact Set.mem_prod.mpr ‚ü®z0m, mem_open_closed w1m‚ü©

/-- `f` is continuous in `z1` -/
theorem Separate.fc1 (h : Separate f c0 c1 r b s) (w0m : w0 ‚àà closedBall c0 r) :
    ContinuousOn (fun z1 ‚Ü¶ f (w0, z1)) (closedBall c1 r) := by
  refine' ContinuousOn.comp h.fc _ _
  exact ContinuousOn.prod continuousOn_const continuousOn_id
  intro z1 z1m; apply h.rs
  rw [‚Üê closedBall_prod_same]; exact Set.mem_prod.mpr ‚ü®w0m, z1m‚ü©

/-- `f` is differentiable in `z0` -/
theorem Separate.fd0 (h : Separate f c0 c1 r b s) (w0m : w0 ‚àà closedBall c0 r)
    (w1m : w1 ‚àà closedBall c1 r) : DifferentiableAt ‚ÑÇ (fun z0 ‚Ü¶ f (z0, w1)) w0 :=
  haveI m : (w0, w1) ‚àà s := by
    apply h.rs; rw [‚ÜêclosedBall_prod_same]; exact Set.mem_prod.mpr ‚ü®w0m, w1m‚ü©
  AnalyticAt.differentiableAt (h.fa0 m)

/-- `f` is differentiable in `z1` -/
theorem Separate.fd1 (h : Separate f c0 c1 r b s) (w0m : w0 ‚àà closedBall c0 r)
    (w1m : w1 ‚àà closedBall c1 r) : DifferentiableAt ‚ÑÇ (fun z1 ‚Ü¶ f (w0, z1)) w1 :=
  haveI m : (w0, w1) ‚àà s := by
    apply h.rs; rw [‚ÜêclosedBall_prod_same]; exact Set.mem_prod.mpr ‚ü®w0m, w1m‚ü©
  AnalyticAt.differentiableAt (h.fa1 m)

/-- Simplied 1D Cauchy integral formula, assuming differentiability everywhere in the interior -/
theorem cauchy1 {r : ‚Ñù} {c w : ‚ÑÇ} {f : ‚ÑÇ ‚Üí E} (wm : w ‚àà ball c r)
    (fc : ContinuousOn f (closedBall c r)) (fd : ‚àÄ z, z ‚àà ball c r ‚Üí DifferentiableAt ‚ÑÇ f z) :
    (2*œÄ*I : ‚ÑÇ)‚Åª¬π ‚Ä¢ (‚àÆ z in C(c, r), (z - w)‚Åª¬π ‚Ä¢ f z) = f w := by
  refine' Complex.two_pi_I_inv_smul_circleIntegral_sub_inv_smul_of_differentiable_on_off_countable
    Set.countable_empty wm fc _
  intro z zm; apply fd z _; simp only [Metric.mem_ball, Set.diff_empty] at zm ‚ä¢; assumption

/-- The 2D Cauchy integral formula -/
theorem cauchy2 (h : Separate f c0 c1 r b s) (w0m : w0 ‚àà ball c0 r) (w1m : w1 ‚àà ball c1 r) :
    (2*œÄ*I : ‚ÑÇ)‚Åª¬π ‚Ä¢ (‚àÆ z0 in C(c0, r), (z0 - w0)‚Åª¬π ‚Ä¢ (2*œÄ*I : ‚ÑÇ)‚Åª¬π ‚Ä¢
      (‚àÆ z1 in C(c1, r), (z1 - w1)‚Åª¬π ‚Ä¢ f (z0, z1))) =
      f (w0, w1) := by
  have h1 := fun z0 (z0m : z0 ‚àà closedBall c0 r) ‚Ü¶
    cauchy1 w1m (h.fc1 z0m) fun z1 z1m ‚Ü¶ h.fd1 z0m (mem_open_closed z1m)
  have ic1 : ContinuousOn (fun z0 ‚Ü¶ (2 * œÄ * I : ‚ÑÇ)‚Åª¬π ‚Ä¢ ‚àÆ z1 in C(c1, r), (z1 - w1)‚Åª¬π ‚Ä¢ f (z0, z1))
      (closedBall c0 r) :=
    (h.fc0 w1m).congr h1
  have id1 : DifferentiableOn ‚ÑÇ (fun z0 ‚Ü¶ (2 * œÄ * I : ‚ÑÇ)‚Åª¬π ‚Ä¢ ‚àÆ z1 in C(c1, r), (z1 - w1)‚Åª¬π
      ‚Ä¢ f (z0, z1)) (ball c0 r) := by
    rw [differentiableOn_congr fun z zs ‚Ü¶ h1 z (mem_open_closed zs)]
    intro z0 z0m; apply DifferentiableAt.differentiableWithinAt
    exact h.fd0 (mem_open_closed z0m) (mem_open_closed w1m)
  have h01 :=
    cauchy1 w0m ic1 fun z0 z0m ‚Ü¶
      DifferentiableOn.differentiableAt id1 (IsOpen.mem_nhds isOpen_ball z0m)
  exact _root_.trans h01 (h1 w0 (mem_open_closed w0m))

/-- One 2D coefficient of the 2D Cauchy series -/
@[nolint unusedArguments]  -- Don't complain about the first argument
def Separate.series2Coeff (_ : Separate f c0 c1 r b s) (n0 n1 : ‚Ñï) : E :=
  (2*œÄ*I : ‚ÑÇ)‚Åª¬π ‚Ä¢ ‚àÆ z0 in C(c0, r), (z0 - c0)‚Åª¬π ^ n0 ‚Ä¢ (z0 - c0)‚Åª¬π ‚Ä¢
    (2*œÄ*I : ‚ÑÇ)‚Åª¬π ‚Ä¢ ‚àÆ z1 in C(c1, r), (z1 - c1)‚Åª¬π ^ n1 ‚Ä¢ (z1 - c1)‚Åª¬π ‚Ä¢ f (z0, z1)

/-- `series2Coeff` summed over `n0` -/
@[nolint unusedArguments]  -- Don't complain about the first argument
def Separate.series2CoeffN0Sum (_ : Separate f c0 c1 r b s) (n1 : ‚Ñï) (w0 : ‚ÑÇ) : E :=
  (2*œÄ*I : ‚ÑÇ)‚Åª¬π ‚Ä¢ ‚àÆ z0 : ‚ÑÇ in C(c0, r), (z0 - (c0 + w0))‚Åª¬π ‚Ä¢
    (2*œÄ*I : ‚ÑÇ)‚Åª¬π ‚Ä¢ ‚àÆ z1 : ‚ÑÇ in C(c1, r), (z1 - c1)‚Åª¬π ^ n1 ‚Ä¢ (z1 - c1)‚Åª¬π ‚Ä¢ f (z0, z1)

/-- The 1D Cauchy series converges as expected
   (rephrasing of `hasSum_cauchy_power_series_integral`) -/
theorem cauchy1_hasSum {f : ‚ÑÇ ‚Üí E} {c w : ‚ÑÇ} {r : ‚Ñù} (rp : r > 0) (fc : ContinuousOn f (sphere c r))
    (wm : w ‚àà ball (0 : ‚ÑÇ) r) :
    HasSum
      (fun n : ‚Ñï ‚Ü¶ w ^ n ‚Ä¢ (2 * œÄ * I : ‚ÑÇ)‚Åª¬π ‚Ä¢ ‚àÆ z in C(c, r), (z - c)‚Åª¬π ^ n ‚Ä¢ (z - c)‚Åª¬π ‚Ä¢ f z)
      ((2 * œÄ * I : ‚ÑÇ)‚Åª¬π ‚Ä¢ ‚àÆ z in C(c, r), (z - (c + w))‚Åª¬π ‚Ä¢ f z) := by
  simp at wm
  have ci : CircleIntegrable f c r := ContinuousOn.circleIntegrable (by linarith) fc
  have h := hasSum_cauchyPowerSeries_integral ci wm
  simp_rw [cauchyPowerSeries_apply] at h
  generalize hs : (2*œÄ*I : ‚ÑÇ)‚Åª¬π = s; simp_rw [hs] at h
  generalize hg : (s ‚Ä¢ ‚àÆ z : ‚ÑÇ in C(c, r), (z - (c + w))‚Åª¬π ‚Ä¢ f z) = g; rw [hg] at h
  simp_rw [div_eq_mul_inv, mul_pow, ‚Üê smul_smul, circleIntegral.integral_smul, smul_comm s _] at h
  assumption

/-- Circle integrals are continuous if the function varies continuously -/
theorem ContinuousOn.circleIntegral {f : ‚ÑÇ ‚Üí ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} (rp : r > 0) (cs : IsCompact s)
    (fc : ContinuousOn (uncurry f) (s √óÀ¢ sphere c1 r)) :
    ContinuousOn (fun z0 ‚Ü¶ ‚àÆ z1 in C(c1, r), f z0 z1) s := by
  rcases fc.bounded_norm (IsCompact.prod cs (isCompact_sphere _ _)) with ‚ü®b, _, bh‚ü©
  intro z1 z1s
  have fb : ‚àÄ·∂† x : ‚ÑÇ in ùìù[s] z1, ‚àÄ·µê t : ‚Ñù, t ‚àà Set.uIoc 0 (2 * œÄ) ‚Üí
      ‚Äñderiv (circleMap c1 r) t ‚Ä¢ (fun z1 : ‚ÑÇ ‚Ü¶ f x z1) (circleMap c1 r t)‚Äñ ‚â§ r * b := by
    apply eventually_nhdsWithin_of_forall; intro x xs
    apply MeasureTheory.ae_of_all _; intro t _; simp only [deriv_circleMap]
    rw [norm_smul, Complex.norm_eq_abs]
    simp only [map_mul, abs_circleMap_zero, Complex.abs_I, mul_one]
    have bx := bh (x, circleMap c1 r t) (Set.mk_mem_prod xs (circleMap_mem_sphere c1
      (by linarith) t))
    simp only [uncurry] at bx
    calc |r| * ‚Äñf x (circleMap c1 r t)‚Äñ ‚â§ |r| * b := by bound
      _ = r * b := by rw [abs_of_pos rp]
  refine' intervalIntegral.continuousWithinAt_of_dominated_interval _ fb (by simp) _
  ¬∑ apply eventually_nhdsWithin_of_forall; intro x xs
    apply ContinuousOn.aestronglyMeasurable
    apply ContinuousOn.smul; simp
    exact ContinuousOn.mul (Continuous.continuousOn (continuous_circleMap _ _)) continuousOn_const
    have comp : (fun t ‚Ü¶ f x (circleMap c1 r t)) = uncurry f ‚àò fun t ‚Ü¶ (x, circleMap c1 r t) := by
      apply funext; intro t; simp
    simp; rw [comp]; apply ContinuousOn.comp fc
    exact ContinuousOn.prod continuousOn_const (Continuous.continuousOn (continuous_circleMap _ _))
    intro t _; simp; exact ‚ü®xs, by linarith‚ü©
    exact measurableSet_uIoc
  ¬∑ apply MeasureTheory.ae_of_all _; intro t _; simp
    apply ContinuousOn.smul continuousOn_const
    have comp : (fun x ‚Ü¶ f x (circleMap c1 r t)) = uncurry f ‚àò fun x ‚Ü¶ (x, circleMap c1 r t) := by
      apply funext; intro t; simp
    rw [comp]; apply ContinuousOn.comp fc (ContinuousOn.prod continuousOn_id continuousOn_const)
    intro x xs; simp; exact ‚ü®xs, by linarith‚ü©
    exact z1s

/-- Inverses are continuous on the sphere -/
theorem ContinuousOn.inv_sphere {c : ‚ÑÇ} {r : ‚Ñù} (rp : r > 0) :
    ContinuousOn (fun z ‚Ü¶ (z - c)‚Åª¬π) (sphere c r) :=
  ContinuousOn.inv‚ÇÄ (ContinuousOn.sub continuousOn_id continuousOn_const) fun _ zs ‚Ü¶
    center_not_in_sphere rp zs

/-- Shifted inverses are continuous on the sphere -/
theorem ContinuousOn.inv_sphere_ball {c w : ‚ÑÇ} {r : ‚Ñù} (wr : w ‚àà ball (0 : ‚ÑÇ) r) :
    ContinuousOn (fun z ‚Ü¶ (z - (c + w))‚Åª¬π) (sphere c r) := by
  refine' ContinuousOn.inv‚ÇÄ (ContinuousOn.sub continuousOn_id continuousOn_const) fun z zs ‚Ü¶ _
  rw [‚ÜêComplex.abs.ne_zero_iff]
  simp only [mem_ball_zero_iff, Complex.norm_eq_abs, mem_sphere_iff_norm] at zs wr
  apply ne_of_gt
  calc abs (z - (c + w))
    _ = abs (z - c + -w) := by ring_nf
    _ ‚â• abs (z - c) - abs (-w) := by bound
    _ = r - abs (-w) := by rw [zs]
    _ = r - abs w := by rw [Complex.abs.map_neg]
    _ > r - r := (sub_lt_sub_left wr _)
    _ = 0 := by ring

/-- Cauchy series terms are continuous in the function -/
theorem ContinuousOn.cauchy1 {n1 : ‚Ñï} (rp : r > 0)
    (fc : ContinuousOn f (sphere c0 r √óÀ¢ sphere c1 r)) :
    ContinuousOn (fun z0 ‚Ü¶ ‚àÆ z1 in C(c1, r), (z1 - c1)‚Åª¬π ^ n1 ‚Ä¢ (z1 - c1)‚Åª¬π ‚Ä¢ f (z0, z1))
      (sphere c0 r) := by
  apply ContinuousOn.circleIntegral rp (isCompact_sphere _ _)
  apply ContinuousOn.smul; apply ContinuousOn.pow; apply ContinuousOn.inv‚ÇÄ
  apply Continuous.continuousOn
  exact Continuous.sub (Continuous.snd continuous_id) continuous_const
  intro x xp; exact center_not_in_sphere rp (Set.mem_prod.mp xp).right
  apply ContinuousOn.smul; apply ContinuousOn.inv‚ÇÄ
  apply Continuous.continuousOn
  exact Continuous.sub (Continuous.snd continuous_id) continuous_const
  intro x xp; exact center_not_in_sphere rp (Set.mem_prod.mp xp).right
  simp; exact fc

/-- Summing over `n0` in the 2D series does the right thing -/
theorem cauchy2_hasSum_n0 (h : Separate f c0 c1 r b s) (w0m : w0 ‚àà ball (0 : ‚ÑÇ) r) (n1 : ‚Ñï) :
    HasSum (fun n0 : ‚Ñï ‚Ü¶ w0 ^ n0 ‚Ä¢ h.series2Coeff n0 n1) (h.series2CoeffN0Sum n1 w0) :=
  haveI cc1 : ContinuousOn (fun z0 ‚Ü¶
      (2 * œÄ * I : ‚ÑÇ)‚Åª¬π ‚Ä¢ ‚àÆ z1 in C(c1, r), (z1 - c1)‚Åª¬π ^ n1 ‚Ä¢ (z1 - c1)‚Åª¬π ‚Ä¢ f (z0, z1))
      (sphere c0 r) :=
    ContinuousOn.smul continuousOn_const (ContinuousOn.cauchy1 h.rp (ContinuousOn.mono h.fc h.rs'))
  cauchy1_hasSum h.rp cc1 w0m

/-- Sums commute with `circle_integral` under reasonable hypotheses -/
theorem sum_integral_commute {f : ‚Ñï ‚Üí ‚ÑÇ ‚Üí E} {g : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} {r : ‚Ñù} (b : ‚Ñï ‚Üí ‚Ñù) (rp : r > 0)
    (fc : ‚àÄ n, ContinuousOn (f n) (sphere c r)) (fb : ‚àÄ n z, z ‚àà sphere c r ‚Üí ‚Äñf n z‚Äñ ‚â§ b n)
    (bs : Summable b) (h : ‚àÄ z, z ‚àà sphere c r ‚Üí HasSum (fun n ‚Ü¶ f n z) (g z)) :
    HasSum (fun n ‚Ü¶ ‚àÆ z in C(c, r), f n z) (‚àÆ z in C(c, r), g z) := by
  rw [circleIntegral]; simp_rw [circleIntegral]; simp
  apply intervalIntegral.hasSum_integral_of_dominated_convergence fun n _ ‚Ü¶ r * b n
  ¬∑ intro n; apply ContinuousOn.aestronglyMeasurable; apply ContinuousOn.smul
    apply ContinuousOn.mul (Continuous.continuousOn (continuous_circleMap _ _)) continuousOn_const
    apply ContinuousOn.comp (fc n) (Continuous.continuousOn (continuous_circleMap _ _))
    intro t _; exact circleMap_mem_sphere _ (by linarith) _
    exact measurableSet_uIoc
  ¬∑ intro n; apply MeasureTheory.ae_of_all; intro t _; rw [norm_smul, Complex.norm_eq_abs]; simp
    rw [abs_of_pos rp]
    refine' mul_le_mul_of_nonneg_left _ rp.le
    exact fb n (circleMap c r t) (circleMap_mem_sphere _ (by linarith) _)
  ¬∑ apply MeasureTheory.ae_of_all; intro t _
    exact Summable.mul_left _ bs
  ¬∑ simp only [intervalIntegrable_const]
  ¬∑ apply MeasureTheory.ae_of_all; intro t _
    apply HasSum.const_smul
    exact h (circleMap c r t) (circleMap_mem_sphere _ (by linarith) _)

/-- The simple bound on circle_interval -/
theorem bounded_circleIntegral {f : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} {r b : ‚Ñù} (rp : r > 0)
    (fc : ContinuousOn f (sphere c r)) (fb : ‚àÄ z, z ‚àà sphere c r ‚Üí ‚Äñf z‚Äñ ‚â§ b) :
    ‚Äñ‚àÆ z in C(c, r), f z‚Äñ ‚â§ 2 * œÄ * r * b := by
  rw [circleIntegral]; simp only [deriv_circleMap]
  have nonneg_2œÄ := Real.two_pi_pos.le
  have ib : ‚Äñ(‚à´ t in (0)..(2*œÄ), (circleMap 0 r t * I) ‚Ä¢ f (circleMap c r t))‚Äñ ‚â§
      (‚à´ t in (0)..(2*œÄ), ‚Äñ(circleMap 0 r t * I) ‚Ä¢ f (circleMap c r t)‚Äñ) :=
    intervalIntegral.norm_integral_le_integral_norm nonneg_2œÄ
  refine' le_trans ib _; clear ib
  simp_rw [norm_smul, Complex.norm_eq_abs]
  simp only [map_mul, abs_circleMap_zero, Complex.abs_I, mul_one, integral_const_mul]
  have mo : ‚àÄ t, t ‚àà Set.Icc 0 (2 * œÄ) ‚Üí ‚Äñf (circleMap c r t)‚Äñ ‚â§ b := fun t _ ‚Ü¶
    fb (circleMap c r t) (circleMap_mem_sphere c (by linarith) t)
  have i0 : IntervalIntegrable (fun t ‚Ü¶ ‚Äñf (circleMap c r t)‚Äñ) Real.measureSpace.volume
      0 (2*œÄ) := by
    apply ContinuousOn.intervalIntegrable
    have ca : ContinuousOn (norm : E ‚Üí ‚Ñù) Set.univ := Continuous.continuousOn continuous_norm
    refine' ContinuousOn.comp ca _ (Set.mapsTo_univ _ _)
    apply ContinuousOn.comp fc
    exact Continuous.continuousOn (continuous_circleMap _ _)
    intro t _; exact circleMap_mem_sphere _ (by linarith) _
  have i1 : IntervalIntegrable (fun _ ‚Ü¶ b) Real.measureSpace.volume 0 (2 * œÄ) :=
    intervalIntegrable_const
  have im := intervalIntegral.integral_mono_on nonneg_2œÄ i0 i1 mo
  simp only [integral_const, sub_zero, smul_eq_mul] at im
  calc |r| * ‚à´ t in (0)..(2*œÄ), ‚Äñf (circleMap c r t)‚Äñ
    _ ‚â§ |r| * (2 * œÄ * b) := by bound
    _ = r * (2 * œÄ * b) := by rw [abs_of_pos rp]
    _ = 2 * œÄ * r * b := by ring

/-- The 1D Cauchy integral without the constant has the expected bound -/
theorem cauchy1_bound {f : ‚ÑÇ ‚Üí E} {b r : ‚Ñù} {c : ‚ÑÇ} (rp : r > 0)
    (fc : ContinuousOn f (sphere c r)) (bh : ‚àÄ z, z ‚àà sphere c r ‚Üí ‚Äñf z‚Äñ ‚â§ b) (n : ‚Ñï) :
    ‚Äñ‚àÆ z in C(c, r), (z - c)‚Åª¬π ^ n ‚Ä¢ (z - c)‚Åª¬π ‚Ä¢ f z‚Äñ ‚â§ 2 * œÄ * b * r‚Åª¬π ^ n := by
  have sb : ‚àÄ z, z ‚àà sphere c r ‚Üí ‚Äñ(z - c)‚Åª¬π ^ n ‚Ä¢ (z - c)‚Åª¬π ‚Ä¢ f z‚Äñ ‚â§ r‚Åª¬π ^ n * r‚Åª¬π * b := by
    intro z zs; have fb := bh z zs
    rw [norm_smul, norm_smul, Complex.norm_eq_abs, Complex.norm_eq_abs]
    simp only [inv_pow, map_inv‚ÇÄ, map_pow, ge_iff_le, Metric.mem_sphere, Complex.dist_eq] at zs ‚ä¢
    rw [zs]; ring_nf; bound
  have isb := bounded_circleIntegral rp ?_ sb
  ¬∑ calc ‚Äñ‚àÆ z in C(c, r), (z - c)‚Åª¬π ^ n ‚Ä¢ (z - c)‚Åª¬π ‚Ä¢ f z‚Äñ
      _ ‚â§ 2 * œÄ * r * (r‚Åª¬π ^ n * r‚Åª¬π * b) := isb
      _ = 2 * œÄ * b * r‚Åª¬π ^ n * (r * r‚Åª¬π) := by ring
      _ = 2 * œÄ * b * r‚Åª¬π ^ n := by rw [mul_inv_cancel rp.ne']; simp
  ¬∑ apply ContinuousOn.smul; apply ContinuousOn.pow; exact ContinuousOn.inv_sphere rp
    apply ContinuousOn.smul; exact ContinuousOn.inv_sphere rp; assumption

/-- The 1D Cauchy integral with the constant has the expected bound -/
theorem cauchy1_bound' {f : ‚ÑÇ ‚Üí E} {r : ‚Ñù} {c : ‚ÑÇ} (rp : r > 0) (b : ‚Ñù)
    (fc : ContinuousOn f (sphere c r)) (bh : ‚àÄ z, z ‚àà sphere c r ‚Üí ‚Äñf z‚Äñ ‚â§ b) (n : ‚Ñï) :
    ‚Äñ(2*œÄ*I : ‚ÑÇ)‚Åª¬π ‚Ä¢ ‚àÆ z in C(c, r), (z - c)‚Åª¬π ^ n ‚Ä¢ (z - c)‚Åª¬π ‚Ä¢ f z‚Äñ ‚â§ b * r‚Åª¬π ^ n := by
  have a : abs (2*œÄ*I : ‚ÑÇ)‚Åª¬π = (2*œÄ)‚Åª¬π := by
    simp only [mul_inv_rev, Complex.inv_I, neg_mul, map_neg_eq_map, map_mul, Complex.abs_I,
      map_inv‚ÇÄ, Complex.abs_ofReal, Complex.abs_two, one_mul, mul_eq_mul_right_iff, inv_inj,
      abs_eq_self, inv_eq_zero, OfNat.ofNat_ne_zero, or_false]
    exact Real.pi_pos.le
  rw [norm_smul, Complex.norm_eq_abs, a]
  calc (2*œÄ)‚Åª¬π * ‚Äñ‚àÆ z in C(c, r), (z - c)‚Åª¬π ^ n ‚Ä¢ (z - c)‚Åª¬π ‚Ä¢ f z‚Äñ
    _ ‚â§ (2*œÄ)‚Åª¬π * (2*œÄ * b * r‚Åª¬π ^ n) := by bound [cauchy1_bound rp fc bh n, rp, Real.pi_pos]
    _ = (2*œÄ)‚Åª¬π * (2*œÄ) * b * r‚Åª¬π ^ n := by ring
    _ = b * r‚Åª¬π ^ n := by field_simp [Real.pi_pos.ne']

/-- Corollary of cauchy1_bound used in cauchy2_hasSum_n1n0 -/
theorem cauchy2_hasSum_n1n0_bound (h : Separate f c0 c1 r b s) (w0m : w0 ‚àà ball (0 : ‚ÑÇ) r)
    (n : ‚Ñï) {z0 : ‚ÑÇ} (z0s : z0 ‚àà sphere c0 r) :
    ‚Äñw1 ^ n ‚Ä¢ (2 * œÄ * I : ‚ÑÇ)‚Åª¬π ‚Ä¢ (z0 - (c0 + w0))‚Åª¬π ‚Ä¢
      ‚àÆ z1 in C(c1, r), (z1 - c1)‚Åª¬π ^ n ‚Ä¢ (z1 - c1)‚Åª¬π ‚Ä¢ f (z0, z1)‚Äñ ‚â§
      (r - abs w0)‚Åª¬π * b * (abs w1 / r) ^ n := by
  have isb := cauchy1_bound h.rp
    (ContinuousOn.mono (h.fc1 (mem_sphere_closed z0s)) Metric.sphere_subset_closedBall)
    (fun z1 z1s ‚Ü¶ h.fb z0s z1s) n
  simp only [mem_sphere_iff_norm, Complex.norm_eq_abs, Metric.mem_ball, dist_zero_right] at z0s w0m
  have zcw : abs (z0 - (c0 + w0)) ‚â• r - abs w0 := by
    calc abs (z0 - (c0 + w0))
      _ = abs (z0 - c0 + -w0) := by ring_nf
      _ ‚â• abs (z0 - c0) - abs (-w0) := by bound
      _ = r - abs w0 := by rw [z0s]; simp only [map_neg_eq_map]
  have zcw' : (abs (z0 - (c0 + w0)))‚Åª¬π ‚â§ (r - abs w0)‚Åª¬π := by bound
  have pp := Real.pi_pos
  have a : (abs (2 * œÄ * I : ‚ÑÇ))‚Åª¬π = (2 * œÄ)‚Åª¬π := by
    simp only [map_mul, Complex.abs_two, Complex.abs_ofReal, Complex.abs_I, mul_one, mul_inv_rev,
      mul_eq_mul_right_iff, inv_inj, abs_eq_self, inv_eq_zero, OfNat.ofNat_ne_zero, or_false]
    linarith
  rw [norm_smul, norm_smul, norm_smul, Complex.norm_eq_abs, Complex.norm_eq_abs,
    Complex.norm_eq_abs, Complex.abs.map_pow, map_inv‚ÇÄ, map_inv‚ÇÄ, a]
  calc abs w1 ^ n * ((2*œÄ)‚Åª¬π * ((abs (z0 - (c0 + w0)))‚Åª¬π *
      ‚Äñ‚àÆ z1 in C(c1, r), (z1 - c1)‚Åª¬π ^ n ‚Ä¢ (z1 - c1)‚Åª¬π ‚Ä¢ f (z0, z1)‚Äñ))
    _ ‚â§ abs w1 ^ n * ((2 * œÄ)‚Åª¬π * ((abs (z0 - (c0 + w0)))‚Åª¬π * (2 * œÄ * b * r‚Åª¬π ^ n))) := by bound
    _ ‚â§ abs w1 ^ n * ((2 * œÄ)‚Åª¬π * ((r - abs w0)‚Åª¬π * (2 * œÄ * b * r‚Åª¬π ^ n))) := by bound [h.bp, h.rp]
    _ = 2 * œÄ * (2 * œÄ)‚Åª¬π * (r - abs w0)‚Åª¬π * b * (abs w1 ^ n * r‚Åª¬π ^ n) := by ring
    _ = (r - abs w0)‚Åª¬π * b * (abs w1 / r) ^ n := by
      rw [mul_inv_cancel Real.two_pi_pos.ne', ‚Üê mul_pow, ‚Üê div_eq_mul_inv _ r, one_mul]

/-- The outer n1 sum in the 2D series does the right thing -/
theorem cauchy2_hasSum_n1n0 (h : Separate f c0 c1 r b s) (w0m : w0 ‚àà ball (0 : ‚ÑÇ) r)
    (w1m : w1 ‚àà ball (0 : ‚ÑÇ) r) :
    HasSum (fun n1 ‚Ü¶ w1 ^ n1 ‚Ä¢ h.series2CoeffN0Sum n1 w0) (f (c0 + w0, c1 + w1)) := by
  have cw0m : c0 + w0 ‚àà ball c0 r := by
    simpa only [Metric.mem_ball, dist_self_add_left, Complex.norm_eq_abs, Complex.dist_eq,
      sub_zero] using w0m
  have cw1m : c1 + w1 ‚àà ball c1 r := by
    simpa only [Metric.mem_ball, dist_self_add_left, Complex.norm_eq_abs, dist_zero_right] using w1m
  simp_rw [Separate.series2CoeffN0Sum]
  rw [‚Üê cauchy2 h cw0m cw1m]
  generalize hs : (2 * ‚ÜëœÄ * I)‚Åª¬π = s
  simp_rw [smul_comm _ s _]
  apply HasSum.const_smul
  simp_rw [‚Üê circleIntegral.integral_smul (w1 ^ _) _ _ _]
  apply sum_integral_commute (fun n ‚Ü¶ (r - abs w0)‚Åª¬π * b * (abs w1 / r) ^ n) h.rp
  ¬∑ intro n
    apply ContinuousOn.smul continuousOn_const
    apply ContinuousOn.smul continuousOn_const
    apply ContinuousOn.smul
    exact ContinuousOn.inv_sphere_ball w0m
    apply ContinuousOn.cauchy1 h.rp
    apply ContinuousOn.mono h.fc h.rs'
  ¬∑ rw [‚Üê hs]; exact fun n z0 z0s ‚Ü¶ cauchy2_hasSum_n1n0_bound h w0m n z0s
  ¬∑ apply Summable.mul_left
    apply summable_geometric_of_abs_lt_1
    rw [abs_div, abs_of_pos h.rp]; simp at w1m ‚ä¢; exact (div_lt_one h.rp).mpr w1m
  ¬∑ intro z0 z0s
    simp_rw [smul_comm s _]; simp_rw [smul_comm (w1 ^ _) _]; apply HasSum.const_smul
    have fcs : ContinuousOn (fun z1 ‚Ü¶ f (z0, z1)) (sphere c1 r) :=
      ContinuousOn.mono (h.fc1 (Metric.sphere_subset_closedBall z0s))
        Metric.sphere_subset_closedBall
    have hs1 := cauchy1_hasSum h.rp fcs w1m
    simp_rw [hs, smul_comm _ s] at hs1
    assumption

/-- 2D Cauchy series terms are geometrically bounded -/
theorem series2Coeff_bound (h : Separate f c0 c1 r b s) (n0 n1 : ‚Ñï) :
    ‚Äñh.series2Coeff n0 n1‚Äñ ‚â§ b * r‚Åª¬π ^ (n0 + n1) := by
  have inner_c :
    ContinuousOn
      (fun z0 ‚Ü¶ (2 * œÄ * I : ‚ÑÇ)‚Åª¬π ‚Ä¢ ‚àÆ z1 in C(c1, r), (z1 - c1)‚Åª¬π ^ n1 ‚Ä¢ (z1 - c1)‚Åª¬π ‚Ä¢ f (z0, z1))
      (sphere c0 r) :=
    ContinuousOn.smul continuousOn_const (ContinuousOn.cauchy1 h.rp (ContinuousOn.mono h.fc h.rs'))
  have inner_b : ‚àÄ z0 _, ‚Äñ(2*œÄ*I : ‚ÑÇ)‚Åª¬π ‚Ä¢ ‚àÆ z1 in C(c1, r),
      (z1 - c1)‚Åª¬π ^ n1 ‚Ä¢ (z1 - c1)‚Åª¬π ‚Ä¢ f (z0,z1)‚Äñ ‚â§ b * r‚Åª¬π ^ n1 :=
    fun z0 z0s ‚Ü¶ cauchy1_bound' h.rp b
      (ContinuousOn.mono (h.fc1 (mem_sphere_closed z0s)) Metric.sphere_subset_closedBall)
      (fun z1 ‚Ü¶ h.fb z0s) n1
  have outer := cauchy1_bound' h.rp _ inner_c inner_b n0
  have e : b * r‚Åª¬π ^ n1 * r‚Åª¬π ^ n0 = b * r‚Åª¬π ^ (n0 + n1) := by
    rw [mul_assoc, ‚Üê pow_add, add_comm n0 _]
  rw [Separate.series2Coeff]; rw [e] at outer; exact outer

/-- The 2D Cauchy series -/
def series2 (h : Separate f c0 c1 r b s) : FormalMultilinearSeries ‚ÑÇ (‚ÑÇ √ó ‚ÑÇ) E := fun n ‚Ü¶
  (Finset.range (n + 1)).sum fun n0 ‚Ü¶ termCmmap ‚ÑÇ n n0 (h.series2Coeff n0 (n - n0))

/-- `series2` is (roughly) geometrically bounded -/
theorem series2_norm (h : Separate f c0 c1 r b s) (n : ‚Ñï) :
    ‚Äñseries2 h n‚Äñ ‚â§ (n + 1) * b * r‚Åª¬π ^ n := by
  rw [series2]; simp only [ge_iff_le, inv_pow]
  have tb : ‚àÄ n0, n0 ‚àà Finset.range (n+1) ‚Üí
      ‚ÄñtermCmmap ‚ÑÇ n n0 (h.series2Coeff n0 (n - n0))‚Äñ ‚â§ b * r‚Åª¬π ^ n := by
    intro n0 n0n; simp at n0n
    apply le_trans (termCmmap_norm ‚ÑÇ n n0 (h.series2Coeff n0 (n - n0)))
    have sb := series2Coeff_bound h n0 (n - n0)
    rw [‚Üê Nat.add_sub_assoc (Nat.le_of_lt_succ n0n) n0, Nat.add_sub_cancel_left] at sb
    assumption
  trans (Finset.range (n + 1)).sum fun n0 ‚Ü¶ ‚ÄñtermCmmap ‚ÑÇ n n0 (h.series2Coeff n0 (n - n0))‚Äñ
  ¬∑ bound [norm_sum_le]
  ¬∑ trans (Finset.range (n + 1)).sum fun _ ‚Ü¶ b * r‚Åª¬π ^ n
    ¬∑ bound [Finset.sum_le_sum, norm_smul_le]; intro _ m; exact tb _ m
    ¬∑ clear tb; rw [Finset.sum_const]
      simp only [Finset.card_range, inv_pow, nsmul_eq_mul, Nat.cast_add, Nat.cast_one]
      ring_nf; rfl

/-- `series2` converges within radius r -/
theorem cauchy2_radius (h : Separate f c0 c1 r b s) : ENNReal.ofReal r ‚â§ (series2 h).radius := by
  apply ENNReal.le_of_forall_nnreal_lt
  intro t tr
  rw [‚ÜêENNReal.toReal_lt_toReal (@ENNReal.coe_ne_top t) (@ENNReal.ofReal_ne_top r)] at tr
  rw [ENNReal.coe_toReal, ENNReal.toReal_ofReal h.rp.le] at tr
  apply FormalMultilinearSeries.le_radius_of_summable_nnnorm
  simp_rw [‚Üê norm_toNNReal, ‚Üê NNReal.summable_coe]; simp
  have lo : ‚àÄ n : ‚Ñï, 0 ‚â§ ‚Äñseries2 h n‚Äñ * (t:‚Ñù)^n := by intro; bound
  have hi : ‚àÄ n : ‚Ñï, ‚Äñseries2 h n‚Äñ * (t:‚Ñù)^n ‚â§ (n + 1) * b * (t / r) ^ n := by
    intro n; trans (‚Üën + 1) * b * r‚Åª¬π ^ n * (t:‚Ñù)^n
    ¬∑ bound [series2_norm h n]
    ¬∑ rw [mul_assoc ((‚Üën + 1) * b) _ _, ‚Üê mul_pow, inv_mul_eq_div]
  refine' summable_of_nonneg_of_le lo hi _
  simp_rw [mul_comm _ b, mul_assoc b _ _]; apply Summable.mul_left b
  have trn : ‚Äñ‚Üët / r‚Äñ < 1 := by simp; rw [abs_of_pos h.rp, div_lt_one h.rp]; assumption
  simp_rw [right_distrib _ _ _, one_mul]
  exact Summable.add (hasSum_coe_mul_geometric_of_norm_lt_1 trn).summable
    (hasSum_geometric_of_norm_lt_1 trn).summable

/-- The 2D series converges to `f` -/
theorem cauchy2_hasSum_2d (h : Separate f c0 c1 r b s) (w0m : w0 ‚àà ball (0 : ‚ÑÇ) r)
    (w1m : w1 ‚àà ball (0 : ‚ÑÇ) r) :
    HasSum (fun n : ‚Ñï √ó ‚Ñï ‚Ü¶ w0 ^ n.snd ‚Ä¢ w1 ^ n.fst ‚Ä¢ h.series2Coeff n.snd n.fst)
      (f (c0 + w0, c1 + w1)) := by
  generalize ha : f (c0 + w0, c1 + w1) = a
  generalize hf : (fun n : ‚Ñï √ó ‚Ñï ‚Ü¶ w0 ^ n.snd ‚Ä¢ w1 ^ n.fst ‚Ä¢ h.series2Coeff n.snd n.fst) = f
  generalize hg : (fun n1 : ‚Ñï ‚Ü¶ w1 ^ n1 ‚Ä¢ h.series2CoeffN0Sum n1 w0) = g
  generalize ha' : ‚àë' n, f n = a'
  have gs : HasSum g a := by rw [‚Üê hg, ‚Üê ha]; exact cauchy2_hasSum_n1n0 h w0m w1m
  have fs : ‚àÄ n1 : ‚Ñï, HasSum (fun n0 ‚Ü¶ f ‚ü®n1, n0‚ü©) (g n1) := by
    intro n1; rw [‚Üê hf, ‚Üê hg]; simp only
    simp_rw [smul_comm (w0 ^ _) _]; apply HasSum.const_smul; exact cauchy2_hasSum_n0 h w0m n1
  have fb : ‚àÄ n : ‚Ñï √ó ‚Ñï, ‚Äñf n‚Äñ ‚â§ b * (abs w0 / r) ^ n.snd * (abs w1 / r) ^ n.fst := by
    intro n; rw [‚Üê hf]; simp
    rw [norm_smul, norm_smul, mul_assoc]
    rw [Complex.norm_eq_abs, Complex.norm_eq_abs, ‚Üê mul_assoc]; simp
    trans abs w0 ^ n.snd * abs w1 ^ n.fst * (b * r‚Åª¬π ^ (n.snd + n.fst))
    ¬∑ bound [series2Coeff_bound h n.snd n.fst]
    ¬∑ rw [pow_add, div_eq_mul_inv, div_eq_mul_inv, inv_pow, inv_pow]; ring_nf; rfl
  have sf : Summable f := by
    simp only [Metric.mem_ball, dist_zero_right, Complex.norm_eq_abs] at w0m w1m
    refine' summable_of_norm_bounded _ _ fb
    simp_rw [mul_assoc]; apply Summable.mul_left; simp_rw [mul_comm ((abs w0 / r) ^ _) _]
    apply Summable.mul_of_nonneg
    ¬∑ exact summable_geometric_of_lt_1 (by bound [h.rp]) ((div_lt_one h.rp).mpr w1m)
    ¬∑ exact summable_geometric_of_lt_1 (by bound [h.rp]) ((div_lt_one h.rp).mpr w0m)
    ¬∑ intro n; simp only [Pi.zero_apply, div_pow]; bound [h.rp]
    ¬∑ intro n; simp only [Pi.zero_apply, div_pow]; bound [h.rp]
  have fs' : HasSum f a' := by rw [‚Üê ha']; exact sf.hasSum
  have gs' := HasSum.prod_fiberwise fs' fs; simp at gs'
  rwa [HasSum.unique gs gs']

/-- We convert the 2D sum to a 1D outer sum with an inner finite antidiagonal -/
theorem HasSum.antidiagonal_of_2d {f : ‚Ñï √ó ‚Ñï ‚Üí E} {a : E} (h : HasSum f a) :
    HasSum (fun n ‚Ü¶ (Finset.range (n + 1)).sum fun n1 ‚Ü¶ f (n1, n - n1)) a := by
  generalize hg : (fun n ‚Ü¶ (Finset.range (n + 1)).sum fun n1 ‚Ü¶ f (n1, n - n1)) = g
  rw [‚ÜêFinset.Nat.sigmaAntidiagonalEquivProd.hasSum_iff] at h
  have fg : ‚àÄ n, HasSum (fun d : Finset.Nat.antidiagonal n ‚Ü¶
      (f ‚àò Finset.Nat.sigmaAntidiagonalEquivProd) ‚ü®n, d‚ü©) (g n) := by
    intro n; simp only [Function.comp_apply, Finset.Nat.sigmaAntidiagonalEquivProd_apply]
    have fs := hasSum_fintype fun d : ‚Ü•(Finset.Nat.antidiagonal n) ‚Ü¶ f ‚Üëd
    -- simp at fs,
    have e : (Finset.univ.sum fun d : ‚Ü•(Finset.Nat.antidiagonal n) ‚Ü¶ f ‚Üëd) = g n := by
      rw [Finset.sum_coe_sort, Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk, ‚Üê hg]
    rwa [‚Üê e]
  exact HasSum.sigma h fg

/-- `series2` converges to `f` -/
theorem cauchy2_hasSum (h : Separate f c0 c1 r b s) (w0m : w0 ‚àà ball (0 : ‚ÑÇ) r)
    (w1m : w1 ‚àà ball (0 : ‚ÑÇ) r) :
    HasSum (fun n ‚Ü¶ series2 h n fun _ : Fin n ‚Ü¶ (w0, w1)) (f (c0 + w0, c1 + w1)) := by
  have sum := (cauchy2_hasSum_2d h w0m w1m).antidiagonal_of_2d; simp only [ge_iff_le] at sum
  generalize ha : f (c0 + w0, c1 + w1) = a; rw [ha] at sum; clear ha
  have e : (fun n ‚Ü¶
      (Finset.range (n + 1)).sum fun n1 ‚Ü¶ w0 ^ (n - n1) ‚Ä¢ w1 ^ n1 ‚Ä¢ h.series2Coeff (n - n1) n1) =
      fun n ‚Ü¶ series2 h n fun _ : Fin n ‚Ü¶ (w0, w1) := by
    clear sum; funext n
    rw [series2]; simp only [ge_iff_le, ContinuousMultilinearMap.sum_apply]
    simp_rw [termCmmap_apply]
    nth_rw 1 [‚Üê Finset.sum_range_reflect]; simp
    apply Finset.sum_congr rfl
    intro n0 n0n'; simp only [Finset.mem_range] at n0n'
    have n0n := Nat.le_of_lt_succ n0n'
    rw [Nat.sub_sub_self n0n, min_eq_left n0n]
  rwa [‚Üêe]

/-- Osgood's lemma on a `closedBall`: `f` is jointly analytic -/
theorem osgood_h (h : Separate f c0 c1 r b s) :
    HasFPowerSeriesOnBall f (series2 h) (c0, c1) (ENNReal.ofReal r) :=
  { r_le := cauchy2_radius h
    r_pos := by simp; exact h.rp
    hasSum := by
      simp only [Metric.emetric_ball, Metric.mem_ball, dist_zero_right, Prod.forall]
      intro w0 w1 wr; rw [Prod.norm_def] at wr
      simp only [Complex.norm_eq_abs, ge_iff_le, max_lt_iff] at wr
      have w0m : w0 ‚àà ball (0 : ‚ÑÇ) r := by simp; exact wr.left
      have w1m : w1 ‚àà ball (0 : ‚ÑÇ) r := by simp; exact wr.right
      exact cauchy2_hasSum h w0m w1m }

end osgood

/-- Osgood's lemma: if `f` is separately analytic on an open set,
    it is jointly analytic on that set -/
theorem osgood {E : Type} {f : ‚ÑÇ √ó ‚ÑÇ ‚Üí E} {s : Set (‚ÑÇ √ó ‚ÑÇ)} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E]
    [CompleteSpace E] (o : IsOpen s) (fc : ContinuousOn f s)
    (fa0 : ‚àÄ z0 z1 : ‚ÑÇ, (z0, z1) ‚àà s ‚Üí AnalyticAt ‚ÑÇ (fun z0 ‚Ü¶ f (z0, z1)) z0)
    (fa1 : ‚àÄ z0 z1 : ‚ÑÇ, (z0, z1) ‚àà s ‚Üí AnalyticAt ‚ÑÇ (fun z1 ‚Ü¶ f (z0, z1)) z1) :
    AnalyticOn ‚ÑÇ f s := by
  intro c cs
  rcases Metric.isOpen_iff.mp o c cs with ‚ü®r, rp, rs‚ü©
  have rs : closedBall c (r / 2) ‚äÜ s := le_trans (Metric.closedBall_subset_ball (by linarith)) rs
  rcases (ContinuousOn.mono fc rs).bounded_norm (isCompact_closedBall _ _) with ‚ü®b, bp, bh‚ü©
  have h : Separate f c.fst c.snd (r / 2) b s :=
    { rp := by linarith
      so := o
      rs := rs
      fc := fc
      fa0 := fa0 _ _
      fa1 := fa1 _ _
      bp := bp
      fb := fun {z0 z1} z0m z1m ‚Ü¶ bh (z0, z1)
        (spheres_subset_closedBall (Set.mk_mem_prod z0m z1m)) }
  have a := (osgood_h h).analyticAt
  simpa only [Prod.mk.eta] using a

/-- Osgood's lemma at a point: if `f` is separately analytic near a point,
    it is jointly analytic there -/
theorem osgood_at' {E : Type} {f : ‚ÑÇ √ó ‚ÑÇ ‚Üí E} {c : ‚ÑÇ √ó ‚ÑÇ} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E]
    [CompleteSpace E]
    (h : ‚àÄ·∂† x : ‚ÑÇ √ó ‚ÑÇ in ùìù c, ContinuousAt f x ‚àß
      AnalyticAt ‚ÑÇ (fun z ‚Ü¶ f (z, x.2)) x.1 ‚àß AnalyticAt ‚ÑÇ (fun z ‚Ü¶ f (x.1, z)) x.2) :
    AnalyticAt ‚ÑÇ f c := by
  rcases eventually_nhds_iff.mp h with ‚ü®s, h, o, cs‚ü©
  exact osgood o (fun _ m ‚Ü¶ (h _ m).1.continuousWithinAt) (fun _ _ m ‚Ü¶ (h _ m).2.1)
    (fun _ _ m ‚Ü¶ (h _ m).2.2) c cs

/-- Osgood's lemma at a point: if `f` is separately analytic near a point,
    it is jointly analytic there -/
theorem osgood_at {E : Type} {f : ‚ÑÇ √ó ‚ÑÇ ‚Üí E} {c : ‚ÑÇ √ó ‚ÑÇ} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E]
    [CompleteSpace E] (fc : ‚àÄ·∂† x in ùìù c, ContinuousAt f x)
    (fa0 : ‚àÄ·∂† x : ‚ÑÇ √ó ‚ÑÇ in ùìù c, AnalyticAt ‚ÑÇ (fun z ‚Ü¶ f (z, x.2)) x.1)
    (fa1 : ‚àÄ·∂† x : ‚ÑÇ √ó ‚ÑÇ in ùìù c, AnalyticAt ‚ÑÇ (fun z ‚Ü¶ f (x.1, z)) x.2) : AnalyticAt ‚ÑÇ f c :=
  osgood_at' (fc.and (fa0.and fa1))
